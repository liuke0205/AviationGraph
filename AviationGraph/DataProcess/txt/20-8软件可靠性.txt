第8章 软件可靠性
软件可靠性是软件的一种重要的设计特性，只有将可靠性特性设计到软件中，软件才具有所要求的可靠性水平。
保证软件可靠性首先要保证在软件开发过程中，严格按照软件工程规范进行各项工作，此外，还应保证软件开发实现“产业化”，避免采用手工作坊式的开发方式。
8.1软件可靠性的基本概念
8.1.1常用术语与定义
(1)软件指计算机程序及其有关数据和文档，也包括固化了的程序。
(2)错误(error)导致软件中含有缺陷的人为活动。如在软件规范中遗漏或误解用户要求，设计规范中遗漏或误解要求等。
(3)缺陷(fault)是软件错误的具体表现。当遇到它时可能引起故障。一个错误可能是几个缺陷的原因。缺陷是面向开发人员的，是一个过程度量，通常用缺陷数或缺陷密度(缺陷数/每千行代码）表示。
通常利用查看静态程序文本即可发现缺陷。在许多文章中有时对错误和缺陷不加以区分。
(4)故障(failure)程序操作背离了程序需求，当计算机程序中的一个缺陷由某些输入数据诱发时而发生的事件。它可导致计算机程序不能正确地执行所要求的功能。
它是面向用户的，是产品可靠性的度量，通常用故障数或故障强度(故障数/每千执行小时）表示。要想发现故障，就要观察程序执行的行为，软件故障仅在程序执行中才会发生。
(5)软件可靠性在规定的条件下和规定的时间内，软件不引起系统故障的能力；它不但与软件存在的错误有关，而且与系统输入和系统使用有关。
(6)软件可靠性预计根据设计或代码特性(如语句数、源语言或复杂性），对计算机程序将达到的可靠性水平的数字说明。预计所选取的数据应与估计将使用的数据一致。
(7)软件可靠性估计利用当前程序(当前环境，如测试）的可靠性度量给出不同环境(如后期测试或使用阶段）下的可靠性水平。估计要求度量环境和目标环境之间要有定量关系。
(8)软件可靠性评估在规定的时间间隔内，利用观察程序执行情况来得出单一的软件可靠性的值。
最后值得一提的是时间定义。它的定义应具体分析，如，对于分时环境中使用的软件，使用执行时间较好，对于在一段时间内连续使用的系统，则建议使用时钟时间，
而对于许多与人或其他系统相互作用的系统，则建议使用执行数或要求数。
8.1.2软件可靠性与硬件可靠性的区别和联系
软件可靠性和硬件可靠性在许多方面，如基本概念、故障机理、分析模型和设计等方面都存在着很大差别，表8-1从上述几方面对这些差别进行了说明。
项目	硬件可靠性	软件可靠性
基本概念	硬件故障是由于物理效应等引起的	软件故障是由于程序错误引起的
在寿命周期内造成故障的原因
设计阶段
生产阶段
使用阶段	不良设计
质量控制问题
性能降级，维修与操作错误等	需求错误、疏涌、不完整及程序设计错误等
程序编码错误
未检测出的程序错误
使用结果	硬件出现性能降级或耗损	不能正确地执行所要求的功能
决定设计好坏的主要因素	对故障机理的了解程度	程序设计人员的技巧、水平及对需求的正确与否
域	时间	时间和数据
时间关系	浴盆曲线	通常为减函数
数学模型时间域函数数据域增长模型增长
预计技术	理论完善
R=f(λ，t）
指数分布(λ为常数）
威尔尔分布(λ通常是增加的）
正态分布无意义
有多种设计、预计、TAAF框图等，对电子设备可利用
GJB-299A	理论尚不完善
R=f(e，t），e表示错误
模型很多但尚无公认的时间函数模型
错误与输入数据有关
有多种设计，预计，TAAF
模拟，经验公式等
试验(测试）和评估	设计和生产验收	设计验收
设计	GJB-899等方法	缺陷植入等
生产	GJB-899等方法	无
余度技术并联备份多数表决	
能改善任务可靠性
自动故障检测和切换N中取m个	
不能改善可靠性。除非采用不同版本的软件
自动错误检测和校正不适用
接口	硬件按口可见	软件接口是概念性的，不是可见的
环境	可靠性与环境因素有关	外部环境不影响可靠性，但它可能影响程序的输入
表中=λ故障率；TAAF=试验-分析-改进。
硬件可靠性与软件可靠性除了上述区别外，它们也有一些相似之处：
(1)硬件可靠性和软件可靠性均与复杂性有关；
(2)硬件和软件均可利用可靠性增长措施，提高它们的可靠性等。
因此应对硬件可靠性方法和软件可靠性方法之间存在的对偶性进行深入研究，一旦这种对偶性被接受，全部问题将会简化，因为就整个系统而言，硬件及软件问题可能一起得到解决。
硬件和软件的对偶性可用图8-1来描述，该图表示在系统研制的各阶段中的硬件及软件工作的各个要素。
8.2软件错误及其分类
8.2.1软件错误根源
软件本质上是一种把一组离散输入变成另一组离散输出的工具(图8-2)。它由一组编码语句组成，这些语句的功能基本上是下述功能之一：
(1)评估某表达式并将结果存入暂时或永久的存储单元；
(2)决定下一步要执行哪个语句；
(3)执行输入/输出运算。
软件是由人开发的，因此软件错误也是不可避免的。造成软件错误的原因基本上可归结为下述几点：
(1)用户要求本身不完整；
(2)对用户要求不了解，或了解不深；
(3)不了解计算规则；
(4)程序设计人员编写的软件文档较差。
目前，人们通常采用两种方法来发现软件中的错误。
一是程序证明方法。该方法是一种比较正式的数学方法，它通常利用归纳决断法或符号执行法进行证明。
前者通过构建一个以将要证明的语句(通常为输出语句）为结束的有限的逻辑语句序列进行证明(其中每个逻辑语句均应是公理或是应用推理法则从以前语句中导出的语句）；
后者以某些自动的程序校对器为基础。需要说明的是这种方法仍是不完善的。有人曾经发现经过证明是正确的程序中，仍然含有软件错误，这主要是由于证明的对象不当引起的，不是证明方法本身有问题。
另一种方法是程序测试法。该方法通常通过执行一组以发现程序中的错误为目的检验实验来进行。同程序证明方法一样，这种方法在检验程序正确性方面也是不完善的。
因为一种测试方法只能发现某些类型的错误，不可能发现程序中的所有错误，且测试不可能遍历所有路径(进度、费用不允许）。该方法的优点是可提供程序在其实际计算环境中的准确信息。
而程序证明法仅限于得出在某一假设环境中有关程序功效的结论。
8.2.2软件错误分类
软件错误一般可分为语法错误、语义错误、运行期错误、规范错误及性能错误。
8.2.2.1语法错误
软件错误是由于程序代码与语法规则之间的偏差引起的，语法规则控制着翻译程序的语法分析程序和词法分析程序。这类错误是最容易检测的错误。它们可通过目视检查或在程序编译过程中通过机器来发现。
有经验的程序设计人员很少犯此类错误。
8.2.2.2语义错误
语义错误是由于程序代码与计算环境的语义分析程序所接受的代码之间的差异造成的。常见的语义错误是类型校验错误和实现限制错误。它们也可通过翻译程序的语义分析程序或目视检查来检测。
语法和语义错误可在程序的编译阶段检测出来。这种错误主要是由于部分程序设计人员不了解或忽视了他所使用的语言的约束和局限性造成的。
8.2.2.3运行期错误
运行期错误就是程序在实际运行过程中产生的错误。这类错误又可分为三类：
(1)域错误
每当程序变量值超出其说明范围或超出描述变量的硬件的物理极限时便会产生这类错误。它们出现时往往会造成程序中断执行或产生错误的结果，而这对实时系统来讲是非常致命的。
目前对这种域错误的研究很少，因为这种错误很难发现，它们要求准确地规定输入变量的范围，而且为发现这些错误所要求的测试值可能会落在输入域边界上或输入域里面。
(2)计算错误
计算错误(有时也称逻辑错误）是由于程序错误的输出造成的。错误输出的原因主要包括公式错误、控制流不正确、对错误变量赋值等。
由于计算错误实际上是程序输出和程序说明书之间的偏差造成的，所以在程序执行过程中不可能产生检测计算错误的运行期代码。
由于程序结构和语句不正确造成的计算错误可利用任何一种与结构有关或与结构无关的测试技术进行检测。由于遗漏程序结构或语句造成的计算错误可利用任何一种与结构无关的技术进行检测，
但对由于误用通道造成的计算错误，目前还没有一种技术能保证全部消除这些错误。
(3)非终止错误
非终止错误就是在没有外界干扰的情况下，程序未能在限定的时刻结束。造成这种错误最常见的原因是程序进入无限循环。如果一组并行程序陷入死锁状态也可能出现这种错误。
通常，通过单纯地执行程序中的每个循环即可检测出无限循环。然而，这种方法不可能全部消除无限循环，有些无限循环只有在某些程序变量达到一定值时才会出现。对某些程序来讲，也可采用程序证明法查找无限循环。
目前程序非终止问题还没有得到圆满解决。
8.2.2.4规范错误
规范错误包括规范不完整、规范不一致、模糊规范等。对规范错误，目前还没有一个正式的检测方法，这主要是由于缺乏一种足以把用户要求转化为清晰的、完整的和一致的术语的规范语言。
8.2.2.5性能错误
只要程序的实际性能与所要求的或规定的性能之间有差别，就会存在性能错误。程序的性能错误可利用下述方法测量。
(1)响应时间；
(2)经过时间；
(3)存储空间利用；
(4)工作区要求等。
目前测量上述程序性能是很困难的、很昂贵和费时的，所以有待于开发出一种经济的性能测量方法。
消除软件错误时耗资最多的是那些直到软件开发后期才发现的错误，这些错误称为持续的软件错误。有人认为这主要是由于软件与用户要求不适应造成的。这类软件问题超出了目前的技术水平，有待于今后解决。
8.3软件可靠性参数及软件可靠性模型
在软件可靠性领域中常采用下述几个可靠性参数：
(1)故障强度λ(t) 这是目前在软件可靠性方面应用最广的一个度量参数。它是指单位执行时间内的平均故障数，在可靠性增长测试期间，主要与软件中的缺陷数、测试环境以及缺陷改进过程有关，其值随着测试过程而下降。
在使用阶段，故障强度主要与软件中的缺陷数和使用环境有关，如果在此期间不增加新性能或不进行修改，那么其值通常保持不变。有时它也称为故障发生率。
在软件可靠性领域还有一个容易与故障强度相混淆的参数，就是危险率或称故障率Z(t)。它相当于硬件领域的瞬时故障率，其定义为：在给定0到t区间内没有发生故障的条件下发生故障的条件概率。
而从故障强度的定义知道，故障强度则不管测试区间前是否发生故障。
(2)可靠度R(t)该参数主要适用于两种类型的系统，一种是极不希望发生故障的系统，另一种是要求在一段时间内必须保证连续工作的系统。它与危险率(以下称故障率）有下述关系：
式中：Z（x）——危险率。
当软件交付使用后，如果在两次交付间不对软件进行改进，那么故障强度将是常量，这样，可靠度还可表示为：
(3)MTTF是当前故障到下一个故障间预期经历的平均时间。该参数目前在软件可靠性领域应用正在逐渐减少，但对使用相对稳定的软件，如使用阶段的软件，可采用该参数。
对于λ变化的情况，如调试和测试期间，不能使用该参数。当故障时间服从指数分布时，该参数与λ之间互为倒数，即MTTF=l/λ。
这里值得一提的是硬件中常用的参数MTBF对软件已不再适用了，因为软件故障可通过重装或重新启动予以排除，只是略微有些延误。
另外，任何软件修改活动都将改变MTBF且软件更改后就成了另外一个软件(版本变化），这在硬件中是不可能的。
(4)可用度该参数定义为在已知初始时刻，软件能满意工作的前提下，在将来某一时刻，软件能满意地执行其功能的概率，在程序可运行且不再修改时，该参数可用软件的能工作时间与能工作时间和不能工作时间之和的比值来描述。该参数主要适用于由于故障造成的停机时间比故障本身更令人担心的系统，如通信系统，
(5)达到某一目标(如规定的λ，R或MTTF等）所需时间该参数主要用于开发期间且主要供管理人员使用，以便可以尽早安排各种资源(包括故障识别人员、故障改正人员、机时等）。
许多大的系统，如操作系统和实时系统也可采用该参数。该参数的一个变种是达到某一目标所需的附加故障数或到某时刻的软件中的残留错误数，这个参数对某些情况也是非常有用的。
表8-2归纳了上述几个度量参数及其应用区域。
度量参数	应用区域	举例
λ(t)	故障频率影响重要的系统	操作系统
R(t)	特别不希望发生故障的系统	航空电子系统。过程控制
MTTF	使用稳定的系统	软件包、控制系统
可用度	停机时间重要的系统	通信系统
达到某目标所需时间	开发阶段	操作系统，大的实时系统
由于我国在软件方面目前积累的数据较少，且大规模生产的方式还不健全，软件的数据收集、评估技术、测试方法等方面都还很不成熟，评估结果置信度并不一定很高，
所以对软件可靠性来讲，在重视定量要求的同时，应特别注意定性要求，甚至重视程度应超过定量要求。
软件可靠性模型是定量度量软件可靠性水平和确定软件开发和测试资源的重要工具。在实际工作中，选择的模型是否合适对软件开发的进度、质量、可靠性等有非常大的影响，当前已经发布并被人们所承认的有数十种模型，
它们分别建立在对故障时间或出现故障数的概率分布及随机过程中变量随时间变化的特性做出不同假设的基础上，这样对同一组软件故障数据，采用不同模型进行评估，就会产生千差万别的结果。
近年来经过大量研究和实际应用，己找出了较切合实际的几个基本模型，这样在实际工作中，就可优先选用这几个模型；
只在这几个模型均不适用时，才去选择其他模型。表8-3列出几个基本模型及其假设条件、可靠性度量、所需数据、应用范围。
表8-3常用的软件可靠性模型
模型名称	假设条件	模型公式	可靠性度量数据要求	应用范围
施奈德温德(Schneidwind)模型
	(1)一个测试间隔内检测的错误数与另一个间隔内的错误数无关；
(2)错误纠正率与将纠正的错误数成正比；
(3)软件以与预定的使用方式相似的方式运行；
(4)检测出的平均错误数从一个间隔到一下间隔逐渐减少；
(5)所有测试间隔长度相同；
(6)错误检测率与测试时程序内的错误数成正比，错误检测过程假定版从错误检测率呈指数下降的非齐次泊松过程	每个测试间隔的错误数综合测试阶段。使用阶段。验收阶段
杰林斯基/莫兰达
(Jelinski/Moranda J-M模型)
	(1)故障检测率与程序中当前的缺陷量成正比。
(2)所有故障相互独立且发生的概率相同。
(3)每个故障的严重和程度相同
(4)在故障发生的间隔内故障强度保持恒定；
(5)软件的运行方式与预期的运行方式相似：
(6)出现故障后马上更改且不引入新的缺陷	故障间隔时间或累积故障时间	综合测试阶段
穆莎(Musa)执行时间模型	(1)软件以与使用方式相类似的方式运行；
(2)程序中的缺陷相互独立且每个缺陷的发生率恒定，故障间隔相互独立
(3)故障间执行时间服从指数成正比
(4)故障率与程序中残留的错误成正比；
(5)所有故障都观察到了；
(6)故障改正率与故障发生率成正比；
(7)在改正过程中可能引入新的缺陷；
(8)每次修改可以改正一个以上的故障
(9)修改时间可以忽略			线性执行频率f错误压缩因子B测试压缩因子C
K，N的初始估计值，错误发生间的ＣＰＵ时间	综合测试阶段。使用阶段。验收阶段
舒曼(Shooman)执行时间模型	(1)初始缺陷量未知但为固定的恒值
(2)程序中每个错误相互独立且发生的可能性相同
(3)在修改过程中不引入新的错误
(4)检测到的错误能保证修正
(5)机器指令数不变(即程序相对稳定）
(6)错误检测率与残留在程序中的错误数成正比；
(7)测试环境与使用环境相似			在两个不同调试时间t1，t2后(保证n(t1）<n(t2），运行一个功能测试，记录测试运行数和每一个测试间和每个运行程序成功执行的CPU时间	综合测试阶段
穆莎/奥库姆塔(Musa/okumoto)对数执行时间模型	(1)软件测试环境与使用环境相类似
(2)各个故障相互独立
(3)故障强度随所遇到的故障呈指数下降			故障间隔时间，或故障发生时间	综合测试阶段。使用阶段。验收阶段
列特伍德/弗洛尔(Littlewood/vorrall)模型				故障间隔时间或故障发生时间	综合测试阶段
有了参数和模型后，在实际应用时还应注意下述几个方面：
(1)选择参数时应注意它要能进行验证；
(2)所选模型应考虑是否能评估所选软件可靠性参数并应注意模型的假设的工程缺陷，因为各种模型的建模对象不完全相同且采用的假设条件也不同；
(3)在实际工作中，即使己选定了模型，也要经常进行修正，以使其保持与实际情况相一致；
(4)上述极型通常不能用于单元测试期间，因为在该测试期间很难保证测试环境与使用环境相符；
(5)当将上述模型用于软件综合阶段或用于评估某改版软件(通过增加语句）时，要注意对模型做适当的修正，因为利用以前软件测试数据确定的模型参数，现在已发生变化，所以建议分阶段利用模型进行评估；
(6)上述模型中有三个执行时间模型，从理论上讲这比采用其他时间更精确，但对软件管理人员执行时间很不直观，另外有时获得的数据并不是执行时间，所以当利用这些模型进行可靠性度量时，
有时需要通过系统的利用率将执行时间和其他时间进行转换；
(7)在利用来自不同计算机上的相同软件的测试数据进行参数估计时，应注意测试数据的一致性，因为许多测试数据是以执行时间来表示的，这样如果各计算机的运算速度不同，
那么所得执行时间数据就会处于不同基准上，所以在这种情况下应将数据转换为同一基准下的数据；
(8)在估算模型参数时，建议最好利用故障间隔时间，而不用成组数据，因为利用成组数据估计的精度较低。
8.4软件可靠性数据
软件可靠性数据是定量评估软件可靠性的必要条件，所以在实际开展软件可靠性工作中应特别注意数据收集工作。对于较大规模的软件，数据收集必须有计划、有组织地进行。
软件可靠性数据分为成组数据和非成组数据。成组数据是指在记录数据时，不是出现一个故障记录一次，而是每隔一段时间记录一次这段时间内所发生的故障数。
这类数据一般不能直接用于计算模型参数，需要对数据进行处理。处理方法有二种：一是将故障在该时间段内按均匀分布随机分配；二是将故障在该时间段内平均分配，这类数据总的来讲误差较大，一般不鼓励收集这样的数据。
非成组数据是指每出现一个故障，就记录一次，该记录可能是故障发生时间，也可能是故障间隔时间。这两类数据细分起来应包括：
(1)发现问题时所处阶段(如测试、使用、维护等）；
(2)故障发生的日期和时间；
(3)自上次故障所经历的CPU时间；
(4)自上次故障所执行的运行数据或测试事例数；
(5)自上次故障所经历的时钟小时数；
(6)每个测试间隔的测试小时数和测试间隔中所检测的故障数；
(7)自上次故障以来的测试人员工时；
(8)故障的严重程度(如致命、重要、次要等）。
对工程应用软件，除了要记录上述数据外，还应记录下列数据：
(1)工程数据
a.生存期各阶段的名称(如要求确定、设计等）；
b.生存期各阶段开始和结束的日期；
c.各阶段所进行的工作；
d.开发进度；
e.开发人员的平均水平；
f.从事该项目的机构数量；
g.软件可靠性估计所使用的重要工具。
(2)成分数据
a.软件规模；
b.所使用的源语言；
c.开发和目标硬件的名称和模型；
d.计算机资源利用情况(平均或高峰）。
(3)缺陷改正数据
a.改正的日期和时间；
b.改正所需的CPU时间；
c.改正所要求的运行数；
d.改正所用的时钟时间；
e.改正所需的人力数。
另外，考虑到软件系统效能和系统(包括硬、软件）效能的度量，还应收集测试期间软件工作时间(或不工作时间）和能表明平均软件恢复时间(MTTRS)的故障数据。
需要说明的两个问题是，对于一个演变的程序来讲，如软件修改、软件扩充等需要对收集的数据进行调整；对于多地点使用的多版本的软件，其数据应加以区别，并应处理后使用。
8.5软件可靠性分配
纯软件的可靠性分配目前还做不到，因为软件与硬件不同，软件中各模块之间各种调用关系非常复杂，同一模块执行不同功能时其使用环境有很大差别，很难给某一模块一个统一的可靠性要求，
此外，由于很难确定各模块的使用环境，即使给出可靠性指标也很难进行验证。根据上述理由，目前在可靠性分配时建议只给出整体软件的可靠性指标(当然对于很大模块的软件，
如果能确定其使用剖面和其他因素则也可根据需要给大的模块分配可靠性指标），最后通过测试、评估等手段加以验证，至于验证的时机、验证所选模型、测试案例等需要承制方与订购方协商确定。
例如对于一个使用三个相同计算机的航天飞行器来讲，如果每台计算机软件都是独立设计和编写的，且可能采用不同的语言、结构和算法，但能完成相同的功能，
那么，如果要求该飞行器执行100小时任务时总的可靠度要求为0.999，则计算机硬、软件即可按下式分配：
然后通过考虑不同费用，即可确定软件的可靠性指标。当然如果有更好的硬、软件复合模型也可采用该模型进行分配。
在分配时需要注意的一个问题是上述分配方法是在保证三个软件相互独立的基础上，即无共因故障的前提下进行的。
在实际工作中，为了保证不存在共因故障，软件设计时应采取相应的措施保证软件的独立性，有时光靠独立设计、编码、采用不同语言、结构和算法并不能完全保证消除共因故障。
8.6软件可靠性预计及估计方法
软件可靠性预计和估计一般有两种方法，一是数学模型法，即利用目前已有的较为成熟的软件可靠性模型(见表8-3)进行预计和估计；二是经验公式法。这两种方法各有优缺点，下面分别加以介绍。
8.6.1数学模型法
利用数学模型法进行软件可靠性预计和估计的关键是解决各模型计算结果的不一致性问题，即模型选择问题。只有模型选择适当，才能保证利用该模型所做的评估真正体现该软件所具有的可靠性水平。
8.6.1.1模型选择准则
模型选择准则是软件可靠性模型选择的依据，它主要包括下述6条准则，这6条准则是按其重要性排序的，选择模型时应特别重视排在前面的准则，但也应对后面几条准则加以全面的考虑。
(1)预计或估计的有效性
预计或估计的有效性是指模型能够根据过去和当前的故障行为预计或估计将来的故障行为的能力。
模型预计和估计的有效性通常可用模型预计的准确性、趋势、偏倚和噪声来度品，其中以准确性应用最广。
准确性检验通常用差额似然法(Prequential Likelihood)进行，通过计算并比较各模型的差额似然函数(PL)来决定哪个模型预计的准确性较好。
假设t1，t2，…，ti-1表示逐次故障间的执行时间，T1，T2，···，Ti-1表示在这些时间所发生故障的随机变量
则PL定义为：假设根据t1，t2，…，ti-1获得的Ti的预计分布i(t)的概率密度函数为：
式中：PLR——差额似然比率。
当时，如果，说明预计模型A比预计模型B要好，即A是可信的，B是不可信的。
趋势度量可用Y图法进行，偏倚度量可用U图法进行，噪声度量也可用中值可变性、率可变性等方法进行。
(2)固有能力
固有能力是指模型能够满意地估计软件定量要求的能力。它通常由能度量的指标的重要性以及估计的定总值准确性来度量，这些定量要求包括：
a当前可靠度、MTTF或故障率；
b预计达到规定的可靠度、MTTF等指标的时间；
c与达到预期目标有关的人、计算机资源和费用要求；
d。所有估计的参数的置信区间。
该准则对初始使用测试/评估来讲是非常重要的，它可帮助测试人员了解当前的软件质量和达到所要求质量将花费的资金。Musa等人通过对18个模型评估发现，指数和几何类模型在这方面具有较好的能力。
(3)假设的合理性
假设是模型的基础。一个软件可靠性模型的假设应尽可能接近真实的测试和使用环境，如果一个假设是可以检验的，就要考虑实际数据能够保障这种假设的程度；
如果假设是不可检验的，就应从逻辑一致性和软件工程经验的观点来评价该假设的合理性。另外，假设的清晰性和明确性也应进行评价。
对于大型复杂系统，有时很难检查假设的有效性，对此情况只能对模型假设与初始使用测试/评估所带的假设进行比较。
(4)可应用性
对于不同的软件产品、不同的开发环境、不同的使用环境和寿命周期阶段，应对模型的可应用性进行评价。即使一个模型仅在较窄的产品或开发环境内给出了满意的结果，那么它也不应被排除掉。
实际工作中常常会遇到下面8种情况，对这8种情况，所选模型应能直接处理它们或与处理它们的方法相兼容。
a.测试期间分阶段综合的程序；
b.设计更改的程序；
c.将故障按严重性分成若干类；
d.处理不完整数据或具有测量不确定性数据的能力；
e.同一程序在不同性能的计算机上使用；
f.故障数据不完整；
g.硬件执行速度不同；
h.项目环境与模型假设不一致。
(5)简单性
对一个模型来讲，简单性通常是指三个方面，一是数据采集应简单且便宜。二是模型本身概念应简单，应保证软件工程师不需要高深的数学知识就能了解模型及其假设的特点，
以便他们可以决定何时使用模型以及模型可能偏离实际的程度；另外参数也应易于说明，以便软件工程师估计参数值。
三是模型应便于实施，这意味着在除初始输入外没有人工干预(不排除人工干预的可能性）的情况下，程序必须能迅速经济地运行。
(6)对噪声不敏感性
软件可靠性数据通常含有与建模过程无关的噪声。最普通的噪声源是，按项目日历时间而不是按软件执行时间记录软件故障数据。
甚至在根据执行时间仔细跟踪软件故障的情况下，软件测试过程也可能与模型假设不一致(例如，不是随机对软件进行测试）。
因此，一个模型应证明它无论在理想情况下还是在故障数据不完全或者会有测试不确定性情况下都有效。
另外，模型输出的分散性以及使用现有初始数据的能力也是在模型选择时要考虑的因素。
8.6.2经验公式法
由于8.6.1节所介绍的模型法，无论从模型选择，还是从预计或估计的精度来讲都还存在很多不足，且许多模型工程化程度较差，使用起来很不方便，
所以在工程界，又逐渐产生了一种经验公式法。它是利用软件的一些基本特性、软件开发环境及应用类型来预计或估计软件的可靠性。
8.6.2.1软件可靠性预计模型
软件可靠性预计的经验模型为
式中：Rp——预计的缺陷密度；
A——应用类型度量；
D——开发环境度量；
S——软件特性度量。
A通常用每于行代码中的缺陷数表示，D和S为修正因子。如果环境和实施倾向于降低故障密度，那么D和S就是小于1的值；反之则大于1。
应用类型是指软件将执行的功能，它是软件的一个基本特性。应用类型不同，软件开发和使用的方式也会不同。
对航空软件来讲通常有6种应用类型：机载类、战略类、战术类、过程控制类、生产中枢类和开发/保障类。应用类型不同，其缺陷密度值也不同表8-4给出了美国RADC统计的美军不同应用类型的缺陷密度值，供参考。
开发环境度量是为了描述开发环境对在其环境内产生的软件的可靠性的影响。开发环境通常可分为三类：系统的、半独立的和嵌入式的。
(1)系统的软件由负责整个系统应用的小组开发(如飞控软件由飞控系统承制开发）。
(2)半独立环境该环境是介于系统的和嵌入式的环境之间的一种环境。软件开发人员具有软件应用领域的知识，但不是负责机构的成员(如网络控制软件是由与目标网络使用无关的通信机构开发的）。
(3)嵌入式环境嵌入式软件与其他软件的一个主要的区别是需要在严格的约束条件下运行，它通常由不直接与用户接触的专业软件机构开发
(例如，警戒雷达软件是由雷达承制方内的一个小组开发的，该小组从组织上与警戒信息用户没有联系）。
这里基本环境是半独立环境，系统环境缺陷密度较低，嵌入式环境则较高。
软件特性度量是对可能影响软件可靠性的那些特性的描述。这可进一步分为要求、设计度量(S1)和软件实施度量(S2)。要求、设计度量包括异常管理(SA)、可跟踪性(ST)、质量评审结果(SQ)三个方面，
且有S1=SA ST SQ；软件实施度量包括语言类型(SL)、模块度(SM)、复杂性(SX)、标准评审结果(SR)四个方面，且有S2=SL SM SX SR。
由此，软件特性度量S=S1	S2=SA	ST	SQ	SL	SM	SX	SR。	(8-7)
A、D、S值的选取，可参阅参考文献[18]。需要说明的是该方法需要大量的工程经验和数据作为基础，在国内使用时应先加以分析才能引用。
8.6.2.28软件可靠性估计模型
软件可靠性估计的经验模型有两个：
在测试环境
式中：Fr1——测试期间所观察到的平均故障率；
Fr2——测试结束时所观察到的故障率；
TE——测试工作量的度量；
TM——测试方法度量；
TC——测试覆盖率的度量。
在使用环境，可以以测试结束时的故障率为基础，针对使用环境加以修正。则
式中：E——为修正因子，其基本值为1;
EV——为输入的控制状态的易变性；
EW——为工作负载
如何确定TE、TM、TC、EV、EW、F11、F12的值请参阅参考文献[18]。
8.7提高软件可靠性的方法
本节介绍几种在软件开发过程中常用的提高软件可靠性的方。
8.7.1正确编写软件规范
经验表明，规范错误占所有软件错误的一半以上。对一个大型软件系统来讲，其规范不应只有一个，而应由一系列适时的规范组成。
这些规范编写应以设计评审点作为阶段分界点，如系统要求评审(SRR)、系统设计评审(SDR)、初步设计评审(DDR)、关键设计评审(CDR)、正式鉴定评审(FQR)等。
系统规范在系统要求评审后确定，并在系统设计评审时加以评审。软件规范要求在初步设计评审期间制定、精炼和评审。
在关键设计评审中详细地编写和讨论计算机程序规范，然后即可进行程序编写，待程序完成后进行正式鉴定评审。
需要说明的是，在每个阶段，规范均应由用户和软件开发人员一起进行审查，且随着阶段的发展评审应逐渐详细，以便保证所开发的软件正确满足用户的要求。
影响软件可靠性的一个主要因素是规范不完整、规范不一致等，目前对于这类问题还没有一种统一的解决方法，常用的解决方法有一种系统验证图法，有关内容可参阅参考文献[19]。
8.7.2认真贯彻软件可靠性设计准则
8.7.2.1规范及文件
(1)在软件设计规范中应详细说明所有的可靠性要求；
(2)应提供预防、检测和解决死锁的技术；
(3)关键软件功能不应利用比该软件的源代码更低的语言进行补片改正。所有补片必须清楚地说明它的意义并记录其配置控制以便将准确的更改记录提交给用户并为用户所接收。
8.7.2.2系统、CPU、关键软件
(1)软件应尽量简单；
(2)软件应采用结构化、模块化设计以减少逻辑错误和改善判定逻辑综合和逻辑错误检测和纠正的能力；
(3)代码逻辑应简单和清晰；
(4)应防止计算机程序发生错误扩展；
(5)应采用编译程序已经成熟的高级语言；
(6)应使用清晰的自然变量名会话；
(7)应使用清晰的和足够的列表法注释；
(8)软件应设计成在通电后即执行系统级的检查以便在可靠性关键的功能(包括软件控制的硬件）工作之前验证系统是否可靠、功能是否正常，对于可靠性关键的功能还应由软件进行周期性的测试以监控系统的状态；
(9)计算机和外部硬件的设计应防止电磁辐射、电磁脉冲或静电干扰的影响；
(10)处理整体指令或数据字的CPU应优先使用那些能多路传输数据和指令的CPU；
(11)应尽量使用能全部用数学表示的微处理机和计算机；
(12)应优先使用具有不同指令、数据存储器和数据总线的CPU而不用具有共用指令、数据总线的CPU；
(13)应对使用共用总线的CPU进行测试以决定总线中各功能间必须发生的时钟循环的最少数量，从而保证CPU不会提取非法信息；
(14)应尽量使用具有简单指令集的CPU，而不使用提供过多指令的CPU；
(15)应尽量使用装有整体指令和数据字的CPU而不用在n部分内装多个指令和数据字的CPU；
(16)按时间共享地址和数据功能间存储总线的CPU在每个总线上应至少提供功能间完整的时钟周期；
(17)应提供看门狗计时器或其他类似的器件以保证微处理机或计算机能正常地工作；
(18)计时器复位功能的设计应保证软件不会进入一个无限循环且计时器复位作为循环序列的一部分；
(19)计时器的值应用代码进行注释，该注释应包括计时器功能和它的值的说明以及选用该值的理由，并进行验证和合理性检查；
(20)应对存储器和数据总线进行周期检查，测试序列的设计应保证能将单点或可能的多个故障检测并隔离；
(21)软件控制的模拟功能应有反馈机理，以正确指示已发生的故障；
(22)系统及其软件的设计应保证便于由设计人员之外的人员进行维护；
(23)操作和支持软件应仅包括那些系统所要求的特性和能力，程序不应包括“要求中未规定的特性”；
(24)系统设计应防止越权或意外地存取或修改软件、信息和目标代码，这包括代码的自修改；
(25)潜在的灾难性或关键的功能应至少由两个独立的功能进行控制；
(26)系统应能检测出可靠性关键的软件部件中的无意的转移，并能将系统恢复到一个安全的状态，如果可能的话，还应进行故障诊断以确定造成无意转移的原因；
(27)标志应是唯一的且用于单一目的；
(28)文件应是唯一的且只应有一个单一的目的，过期文件不应用于存储或传送各次处理之间的安全性关键的信息；
(29)除非绝对必要，否则不应使用间接寻址方法，当使用了该方法时，在执行之前应对地址进行验证以决定其是否在可接收的范围内；
(30)软件应保证能记录系统检测到的所有错误；
(31)运算程序加载应不包括非法可执行代码，应将非法可执行代码从重新编译的源代码和程序中消除；
(32)运算程序加载不应包含未引用的变量；
(33)所有未用存储单元应初始化到一种规定模式，如果执行该模式，将引起系统恢复到一个已知的安全状态(如对—Z-80处理机来讲，进入NOP，NOP，JMP，NOP，NOP，JMP，NOP…
模式的任何输入均将导致转移到0000，而在0000处可以常驻一个重新启动程序）；不得用随机数、HALT、STOP、WAIT或非运算指令来填充该存储器。不应留有以前覆盖和加载的数据或代码；
(34)覆盖应占有相同数量的存储空间，对于一个具体的功能如果要求较少的存储空间的话，那么剩余部分初始化到某一模式(当其执行时会将系统初始化到一个安全的状态），
但不得使用随机数、HALT、STOP、WAIT或非运算指令或以前覆盖的数据或代码来填充；
(35)可靠性关键的软件成分不应用于一对一赋值语句；
(36)可靠性关键的软件成分和接口在任何时刻均应处于正控制之下；
(37)可靠性关键的定时功能应由计算机来控制，而不应依靠人工输入来控制，设计应保证可靠性关键的定时值不应由操作人员从系统控制台上进行修改，除非要求将其作为系统能力的一部分；
(38)可靠性关键的功能应尽量集中，可能的话，应使程序模块的数量尽量少；
(39)条件语句应保证满足所有可能的条件并完全处于软件控制下(即条件语句不应存在未解决的潜在的输入），所有条件语句均应用它们的目的和已知条件的输出作为注释；
(40)安全性关键的功能应表现出较强的数据类型。安全性关键的功能不应采用逻辑“1”和“0”来表示“安全”和“危险”状态，“安全”和“危险”状态应至少使用4位独特的模式来表示，
安全状态就是这样一种模式，即当其中一位或两位发生错误时，不应转变成“危险”状态，但如果检测到这两种独特代码之外的模式，软件应给出错误标志并将系统转换于某一安全状态，同时通过操作人员；
(41)安全性关键的软件部件中的判定语句不应依靠全“1”或全“0”输入且应保证汉明间距大于4，尤其当这些信息是从外部传感器获得时；
(42)应保证控制过程(指可能导致主要系统损失、损伤或人身伤亡的过程）的任一单个CPU不能满足激发关键过程所需的所有要求。在多个CPU环境中，应要求两个以上的CPU来激发该过程在单个CPU环境中，
应利用其他指定的硬件逻辑器件和CPU一起来激发该过程；
(43)CPU之间传送的关键数据应成功地通过两个CPU的数据传送检查；
(44)关键算法的结果应在开发和使用之前进行验证；
(45)存储单元应只有一个唯一的参考基准，即一个名称，以防止全局和局部变量间的存储使用发生冲突；
(46)系统可执行软件在任何时刻均应能提供系统控制能力；
(47)应有措施防止存取指定为关键软件功能的存储区内的指令和数据；
(48)应有措施防止一程序存储区内的指令类型被关键软件功能之外的其他功能所使用；
(49)任何软件不应使用STOP、HALT和WAIT指令或引起CPU处于等待状态的指令。CPU应永远处于执行状态，不管它是否执行任何处理活动；
(50)关键软件所使用的数据应由检错和纠错存储控制器保护；
(51)保证具有恢复或终止发射和武器准备功能的能力；
(52)应防止无意中产生关键命令；
(53)应防止无意中使用关键程序的数据输入控制；
(54)应保证在数据失去同步的情况下不改变状态；
(55)应保证在使用期间内防止存储器的改变或降级；
(56)应保证程序不会受到未授权的更改；
(57)应防止无意中进入关键程序；
(58)应禁止传送已发现错误的任何关键命令并应告诉操作人员；
(59)应保证能检测和终止要求超出系统性能能力的命令；
(60)应保证执行具有潜在危险程序时不进行维修活动；
(61)应防止由于硬件故障或电力中断造成存储器更改；
(62)应保证从存储器内删除清楚的文本型保密代码；
(63)应保证限制控制存取存储器内的文件；
(64)应保证只有当将要传送的数据经过验证并经操作人员认可后才将数据传送出去；
(65)应保证大多数的可靠性关键的决策和算法应包括在单一(几个）的软件开发模块内；
(66)应保证可靠性关键的模块仅有一个输入和一个输出点；
(67)应能检测出偶然的计算机字母输出；
(68)应能检测出在计算机存储器加载到终端过程中的错误；
(69)应能识别出要求连续监控的可靠性关键功能；
(70)应能检测出可能危害可靠性的不适当的处理；
(71)应保证操作人员能够检测出不适当的序列；
(72)应能检测出可靠性关键的程序的偶然传送；
(73)应提供适当的禁止、互锁、安全逻辑和例外极限的配置；
(74)在发出关键的命令前，应保证所观察到的飞行地形与计算机中存储的飞行地形图相匹配；
(75)应以事先规定的格式和内容传送数据。每次传送应包括一个字或字符串用于说明数据的类型和信息的内容，至少应利用奇偶校验和检验和来对正确的数据传送进行检查，在可能的时候，应利用字符识别码；
(76)至少应有两个人完全熟悉系统中每个模块的设计、代码和使用；
(77)软件源代码的评审应保证代码和注释相一致；
(78)在开发过程中应禁止采用补片，所有软件更改应编入源程序中并在输入到测试设备前进行编译。
8.7.2.3可靠性关键的软件成分
(1)控制中断的中断处理机软件、中断优先级图和程序应指定为软件可靠性关键的成分；
(2)软件产生的用于自动控制硬件的信号应指定为软件可靠性关键的成分；
(3)用于显示可靠性关键的硬件系统状态的软件输出应作为软件可靠性关键的成分。
8.7.2.4软件测试
(1)软件测试应包括NO-GO路径测试；
(2)软件测试应包括硬件、软件输入故障式测试；
(3)软件测试应包括边界、边界之外和通过边界的测试条件；
(4)软件测试应包括零输入、过零和从任一方向接近零的输入；
(5)软件测试应包括在最坏配置情况下最小和最大软件数据速率以确定系统的能力和其对该环境的响应；
(6)可靠性关键的软件成分的更改应进行完整的回归测试；
(7)操作人员接口测试应包括可靠性关键操作期间的操作人员错误以验证安全的系统对这些错误的响应。
8.7.2.5验证与确认检查
(1)保证对状态标志进行验证和确定；
(2)保证对关键命令进行确认；
(3)在发布预先规定的操作要求前应对先决条件进行验证；
(4)在使用之前，应对可靠性关键的算法的结果进行验证；
(5)在输出之前，应对可靠性关键的参数和变量进行验证；
(6)检查所有可靠性关键命令信息的顺序和逻辑，当他们发生错误时，拒绝这些命令；
(7)保证用于设定可靠性关键信号的所有操作人员的活动能根据控制器件的位置由软件来进行验证；
(8)确保具有正反馈机理的模拟功能的控制，这种机理可以正确指示已发生的功能；
(9)保证对用于激发危险操作或危险操作序列的提示进行验证和确认；
(10)保证软件系统对所有可靠性关键的输入进行合理性检查；
(11)保证在提供输出前进行奇偶校验或其他要求两个决策的检查。
8.7.2.6CPU-硬件、硬件-CPU接口
(1)当软件将产生一个控制硬件的命令时，应对设计进行分析以确定该命令是否是连续的或只应用到一段时间，目的是为了防止危险定时或潜在定时；
(2)利用寄存器(数据从最终项目硬件、软件中获得）的判定逻辑不应以寄存器所有“1”值为基础；
(3)利用寄存器(数据从最终项目硬件、软件中获得）的判定逻辑不应以寄存器所有的“0”值为基础；
(4)利用寄存器(数据从最终项目硬件、软件中获得）的判定逻辑应要求一个具体的二进制数据模式“1”、“0”以减小满足判定逻辑的最终项目硬件、软件发生故障的可能性；
(5)对武器的激励，“准备”和“发射”命令就应是分开的；
(6)由软件控制的关键硬件应初始化到一个已知的安全状态；
(7)除非专门规定，否则输入、输出端口不应既用于关键功能也用于非关键功能；
(8)关键输入、输出端口地址应与非关键端口有较大区别，以防止由于在端口中有一个单一地址位错误，就将造成不能存取关键功能或端口；
(9)保证杜绝在地面利用发射代码启动准备代码；
(10)反馈回路设计应保证在反馈传感器故障时软件不会造成失控状态。在接口软件设计时应考虑已知的部件故障模式；
(11)输入、输出寄存器和端口不应同时用于可靠性关键的和非关键功能；
(12)在采取措施前，应对所有模拟和数字输入进行极限和合理性检查；
(13)接口软件设计应保证能够检测出外部硬件输入或输出器件的故障并在他们发生时将系统恢复到一个安全的状态，设计应考虑潜在的硬件的故障模式；
(14)接口软件设计应保证软件的满刻度和零表示与数字到模拟、模拟到数字、数字到同步、同步到数字转换的刻度相兼容。
8.7.2.7其他硬件因素、应用、外部影响
(1)计算机系统应不受短时断电的影响；
(2)应周期性地对存储器的完整性进行检查，包括程序和数据存储的检查；
(3)指令存储器ROM的完整性应通过ECC存储器控制器或周期性的软、硬件检验和算法来检查；
(4)应周期地对数据和程序存储器总线进行检查。
8.7.2.8(中断）操作系统、实用软件
(1)应防止在固定栈使用的软件溢出和覆盖其他程序指令或数据；
(2)在调用模块开始执行可共享的CPU资源前，操作系统软件应将所有这些资源放在栈或其他预先规定的存储区域内；
(3)可再入和共享的软件实用程序，如三角函数等，当它们在几个优先的中断过程中使用过后，不应重写他们的暂存区；
(4)可再入和共享的软件不应内部调用其他实用程序，如SIN函数不应调用SQRT函数，TAN函数不能调用LOG函数；
(5)保证软件的中断控制管理以便不会损害可靠性关键的操作。
8.7.2.9操作人员接口
(1)操作人员与软件间的相互作用应明确定义；
(2)软件应保证操作人员可以检测任何不恰当的序列要求；
(3)软件应保证能发现不恰当的键盘输入；
(4)软件应保证操作人员能消除当前处理；
(5)操作人员消除当前处理应只需击一单一键即可；
(6)消除处理应以安全的方式完成；
(7)可靠性互锁的任何失控均应通过测试操作人员的阴极射线管向测试人员报告；
(8)人机交互软件必须使操作人员可以用单一行为消除当前处理的不安全状态并使系统恢复到某一安全状态，使操作人员可以用单一的行为退出潜在的不安全状态，同时使系统恢复到一个已知的安全状态；
(9)操作人员显示、图例和其他相互关系应是清楚的、精确的和不模糊；
(10)人机交互软件必须能够检测出不正确的操作输入和输入序列，并提醒操作人员注意错误的输入和操作，同时指出错误的类型及纠正措施。人机交互软件还必须为合法的数据输入和行为提供正确的证据，
并向操作人员提供可视的或可听的反馈，使得操作人员了解系统已接受该行为并正在处理，系统也应提供实时的表明它正执行要求几秒或更长时间的处理功能并在处理期间向操作人员提供状态指示说明。
8.7.2.10维修
(1)布置在外场的系统中的可靠性关键软件部件的更改应作为一个完整的改进单元或模块而不应利用补片进行维修；
(2)固件更改应作为一个完整的功能和测试电路板的更改。板的设计和安装程序应保证使电路由于静电放电或正常、不正常的存储环境造成的损坏最小。
8.7.2.11其他
(1)保证杜绝管理程序的相关性；
(2)应提供仅包括系统所要求的特性或能力而不包括其他附加能力的软件；
(3)保证可靠性关键子程序中包含有“来自何处”的检查能力以验证调用的正确性；
(4)保证可由附加的操作人员响应对操作人员消除的当前处理进行验证；
(5)保证软件系统可以将可靠性关键的定时数据显示给操作人员。
8.7.3逐步检查法
逐步检查法是当前软件开发过程中普遍采用且非常有效的一种提高软件可靠性的方法，该方法的基本思路是利用严格的阶段把关来保证软件的可靠性。
当一个阶段完成后，需要通过严格的验证和(或）确认才能决定是否允许设计进入下一阶段，如果没有通过验证和(或）确认，那么就应重新进行上一阶段的工作，直至通过为止，
同理对其他阶段，也只有在完成验证和(或）确认后，方能转入下一阶段。
8.7.4故障抑制
软件中很多故障只产生暂时影响，只有在后来计算时选用了这些被污染的数据时，影响才会变成永久性的。故障抑制就是通过避免在后续处理中使用污染的数据，从而防止暂时故障变成永久性故障，来达到提高软件可靠性的目的。
防止数据库污染(具有不正确的计算值）的一种很好的技术是设立中间检查点。即把每个新结果先置于一个称为超高速缓冲存储器(Cache)的暂时存储区，直到检查并确认验收后方能进入数据库。这时Cache即适用下一个计算批量。
这种技术的一个变种是在程序中加入重新运行点。两个重新运行点之间，数据不能送入正规存储器内，在到下一个重新运行点之前，对这些新数据进行测试，如果发现任何疑点，程序即返回前一个重新运行点重新运行。
如果在重新运行点重复故障，那么就要采取一个更严重的恢复步骤，如重新起动程序。如果在测试Cache时没有发现故障，那么该数据可存入正规存储器，程序同时向下一个重新运行点运行。
8.7.5采用避错技术
避错技术是软件设计时常用的方法之一，其目的是尽量消除造成软件故障的各种错误。它通常包括FTA、软件潜在状态分析、计算机程序的动态分析、FMEA等分析技术。
近年来，这些技术已成功地用于若干型号的电传操纵系统和自动飞行控制系统。
8.7.5.1故障树技术
故障树分析(FTA)是一种自上而下的分析技术。它通常设定不希望的事件作为顶事件，然后由熟悉系统级关键事件的人员实施或管理，以识别和消除引起这些不希望事件的状态。
该分析的一个非常重要的用途是把顶级关键事件转变为在分系统级必须防止的事件，然后利用FMECA确定有害事件的潜在原因并设法消除这些事件。
在不可能完全消除的地方，通常必须建立一种新的配置和进行程序重新运行以保证这些有害事件发生的概率低于一个可接受的门限。
软件故障树作为一种有效的分析技术，可在软件的各个层次对各种故障进行分析，较为适用的层次是对软件模块按功能法进行分析。
这里为了简单起见，我们以代码级的一、二种常用的语言结构的故障树为例来说明软件故障树分析。下面以一采用Ada语言编写的程序为例来说明如何进行软件FTA分析。
(1)IF-THEN-ELSE语句
图8-3给出了如何通过IF-THEN-ELSE语句反向进行分析。在该图中，假定在某环境中执行IF-THEN-ELSE语句时引起——故障事件，于是，应建立描述该环境的故障树。图8-4是下面——简单语句的故障树：
图8-4中构建的故障树把顶事件分析简化分解成一些子问题。需要说明的是右边子树所描述的子问题对应于不可能的情况，其概率为零，所以应从故障树中去掉。
该分析可以暂停在该级，并在代码中插入断言语句以检测不安全的状态。可以代替插入断言语句的另一种作法是对条件为A>B，X的函数>100的IF-THEN-ELSE语句之前执行的软件进行详细的分析。
一个完整的分析，将产生顶事件所需的全部故障集和条件集。
(2)赋值语句和过程调用
图8-5及图8-6给出了赋值语句和过程调用的故障树，图8-5是下面短的子程序当事件为“调用调节副翼”的分析。
P：A：=失速速度的平方根
Q：B：=当前速度 -5.0
如果A>B，则调节副翼
图8-6验证了由于参数或算法故障引起的功能调用故障，例如，对一个简单的函数平方根的调用来讲，事件X<100的平方根的调用分析表明：
(1)平方根程序可能故障；
(2)X可能违反平方根规定的参数范围(例如，X<0)；
(3)平方根程序工作正常，但x≤10000也将激励该事件。
8.7.5.2计算机程序的动态分析
计算机程序的动态分析是指对正在执行中的程序性能进行审查。动态分析可检验程序的测试覆盖率，即测试实例是否检查了程序所提供的所有功能。
由于软件不会由于物理劣变而故障，所以验收时软件所具有的能力一般可在整个使用期内保持（或至少到要求一个新版本）。如果软件功能进行了充分测试，并能按要求执行，该软件即可以良好地工作。
影响产生完全无故障软件的障碍是不能在实际计算程序上进行穷举调试。计算机程序的一个有用的特性是它们可以根据预先制定的准则对数据处理进行修改。
这意味着根据输入数据和计算机状态的特征，程序可以采取不同转移。测试覆盖率的度量方法之一是测试期间所经历的转移数与总的转移数之比。
模块化结构程序中的有关度量是所执行的调用与可能的调用（调用是从一个模块到另一个模块的转移）之比。
为了提高覆盖率需要了解那些没有经历的转移以便构成将访问这些转移的测试实例，但是，即使测试覆盖率等于1也不能保证程序永远正确执行。
它还可能由于测试过程中未遇到的数值关系，由于异常的定时状态，或硬件/软件的相互作用而发生故障，然而，动态测试是一种决定程序已进行合理的充分测试的实用工具。
8.7.5.3软件FMEA
软件FMEA目前还不很成熟，这是因为软件中目前还没有标准模块，即使将来有可能也很难确定其故障模式，此外软件中也没有纯粹的故障，所以对软件代码进行FMEA通常是不适用的。
尽管如此，软件FMEA在软件需求分析阶段还是非常有用的。在需求分析阶段该方法分两步进行，第一步，通过分析确定故障模式及其影响，分析内容包括：
a.检查软件要求规范，确定任务必需的要求和故障关键因素。这里任务必需的要求是那些为保证含有软件的系统正确工作必须执行的要求。
故障关键因素是指那些在实现任务目标之前就可能引起程序中断或降级的软件错误，如程序进入死循环，结果造成不能执行其他任务所必需的功能。任务必需的要求和故障关键因素通常可利用过去的经验和数据确定。
b.分析任务关键要求，确定他们之间的相互关系和在计划的使用时间内的时间相关性。这一步也可分两步进行，
第一步，针对每一个任务必需的要求将各个故障关键因素按其严重程度和频率进行排列，并按顺序制成一个关键项目清单，然后给出该任务必须要求的危险函数，这个函数可以是多种多样的，
对于单事件要求来讲，如设置一个启动状态，那么其危险函数可用预计的故障数和总的试验数之比。第二步，检查各任务必需要求间的相互关系，以决定一个函数中的故障是否会影响另一个函数。
c.根据任务期间关键故障发生的频率，对任务必需的要求进行排序。
d.在进一步提炼要求和执行详细的FMEA的基础上，重复上面的各个步骤。在FMEA过程中，已识别的故障模式通过分析方法随机地诱发并评价和记录其影响，
当每一种故障模式都评价后，就可决定对系统级的影响。根据这个方法，系统影响发生的概率即可根据各个危险函数进行计算。
e.修改任务要求，并根据故障数据，重复上述过程。
第二步进行可行性研究，其目的是通过修改软件需求保证将任务期间发生关键故障的风险降低到可接收的水平。其基本作法是针对上面已经制定的任务必需要求的顺序，
研究通过修改要求是否可消除每种关键故障模式或减小其影响。此外，在进行该研究过程中，有时需要对需求说明中涉及的工程方程做出评价，因为对实时系统来讲，准确是保证性能要求的一个重要的前提。
如果经过分析和工程方程的评价，表明故障模式已经消除，那么就应在需求说明中加入检查措施，以保证设计不会重新引入这种问题。
8.7.6加强程序测试
程序测试通常主要在两个阶段进行。在调试阶段，主要对单个模块进行测试（根据模块规范）；而在综合阶段，测试的主要对象则是模块组和整个软件系统（根据一组规范/系统规范）。
当采用结构化编程法时，一般在调试之前，程序已具有相当高的正确性，所以模块测试主要是检验各个程序的所有分支是否能适当地进出。对可觉察的及不可觉察的输入数据都要预先计算结果并对其进行测试。
模块级测试的测试实例通常可利用图8-7所示的简单的网络技术确定，以保证两个决策点之间的所有通道均可至少测试一次，从而当交付综合时，在任何情况下程序均不会发生故障。要求测试的次数与程序的复杂性有关。
采用自顶向下设计是为了保证软件各模块的兼容性和接口的合理性。而自顶向下综合的目的就是为了检查设计的这些方面。综合顺序应首先从顶级模块开始，
此时低级模块用简单的程序存根表示，然后依次综合下一级模块（仍用简单的程序存根表示更低一级的模块）。测试模块所用的测试实例应能体现模块的使用环境，
在综合测试结束时，所有程序单元应能在它们的使用环境中协调地工作。
根据系统分析和软件要求，确定一组测试方案，这组方案可保证能遍历所综合软件的所有使用模式和输入数据。这样，利用这组测试方案即可对软件进行验收以保证软件的所有性能均满足要求。
8.7.7容错技术
对软件来讲，容错技术主要有N版本编程法和恢复程序块法两种，下面分别予以介绍。
8.7.7.1N版本编程法
所谓N版本编程法是指对一个已知功能、大量(N>2)独立编码（可能采用不同算法、语言、结构等）的程序同时（或几乎同时）在松联结的计算机上运行，然后比较运行结果，在出现不一致的情况下，
利用多数表决(N>2)或预先决定的策略决定一个最优先的结果。
容错系统的工作通常包括四项活动：查错、错误评估、错误恢复和故障处理。在N版本编程法中，查错可利用表决检查进行，即利用输出结果的不同，确定故障版本。错误评估的前提是各版本独立执行，
任何损伤仅限于在该版本内，以便保证一个版本故障不会影响其他版本。错误恢复可利用排除表决检查认为错误的输出值来完成。
故障处理则通过排除故障版本的结果来进行，该技术的有效性主要与表决程序、N个版本的设计和N个版本之间的独立性有关。
表决程序设计是N版本编程法成功的关键，为了改善表决的有效性，通常在规范中应包括中间交叉检查值，并且该值应同输出结果一起提交给驱动模块，利用这个中间交叉检查值，
表决即可查出外部状态和版本的内部状态中的错误。当然，中间交叉检查值也将限制各版本的设计独立性。
此外，表决本身应尽可能简单以便使其产生设计故障的可能性最小，当结果包括非离散值时，如实时数值，就可能产生混乱，因为不同算法可能产生稍微不同的正确结果。
这样就要求进行“不精确”表决，在表决前把从各种版本来的结果分成几类，如果有N/2的输出属于一类，那么这些输出中任何一个均可作为系统输出，另外有时也可利用最大一类中的中值作为系统的输出。
使用这种方法的难点是很难定义各类边界。从实际情况来看，表决也是很复杂的，
例如，通常驱动模块不是不暂停那些在规定时间内不能产生输出的版本，而且在实时系统中随着结果的产生，可能需要在飞行中计算表决，以便在所有版本完成前，多数结果可以输出。
当然多数表决不一定适用于所有情况，如在安全非常关键的系统中，应采用一致表决，如果各版本没有产生相同的或同等的结果，那么就应采取措施以保证系统处于故障安全状态。总之，表决类型应根据具体情况具体分析。
由于在N版本法中，各版本通常一起执行，所以必然在每个版本中会保留有各次调用间的数据，因此，N版本法中的各版本应作为含有内部结构的目标程序进行设计，以提高各版本之间的独立程度和减少传递给某版本的数据。
然而这样也会有些问题，如驱动程序将不能重新使用自己产生过错误输出的版本，因为该版本的内部状态已经与其他版本不一致了。
N个程序版本相互独立是保证该技术行之有效的重要基础，建议各版本采用不同算法和编程语言或翻译程序，甚至使用不同数据结构以便要求文件（注意不是规范）可作为N个版本的共同起始点。
N版本编程法中的一个约束是要求计算机硬件独立且能够有效地联络以保证迅速比较结果。这些计算机必须同时工作，其中任何一个硬件故障都将迫使系统进入一个不同的工作模式并以最少的配置引起容错的损失。
两个非相似通道中一个有设计错误，不会产生危险输出。即使两个非相似通道中均有设计错误，也只有在它们的最终影响相同且在通道比较预定时间之内发生时才会产生危险。
N版本编程法的优点是机构简单，不需设计检测程序来确定运行结果的正确与否，但它有以下缺点：
a.处理时间是单文本的N倍；
b.设计所花的力量是单文本的N倍；
c.表决程序设计较困难；
d.当该程序需要与外部事件同步时，或在并行处理中有交互过程时，难于处理。
8.7.7.2恢复程序块法
同N版本编程法相同，恢复块法也是为了防止驻留故障影响系统工作，所不同的是，恢复块的目标是在顺序程序内提供中嵌入的功能部件。图8-8是恢复块法的基本结构。
在该方法中，主模块和备选模块执行相同的功能，只是在设计时所采用的方法不同（遵循的规范也不同）。执行中通过验收测试来决定是否转入备用模块，
如果验收测试没有通过，则程序返回到恢复块入口处的恢复点，并由第一备选模块继续工作，如果第一备选模块又没有通过验收测试，则由第二备选模块代替，依此类推，直到通过验收测试或所有验收测试均失败为止；
如果通过了验收测试，那么就排除恢复点，退出恢复块。如果所有验收测试均没有成功，就会产生故障异常。由于恢复块可以嵌套，所以这种内部恢复块产生的异常将要求在外部块中进行恢复。
恢复块法分为向后恢复和向前恢复，通常使用最多的是向后恢复。向前恢复可作为一种补充，例如，对一个与环境相关的实时程序来讲，如果要求恢复，则环境通常不能与程序一起恢复，结果造成系统处于不一致状态，
然而，如果在环境接口能够采用适当的向前恢复措施，那么系统就可能恢复到一致状态。
1.恢复块验收测试
恢复块法的关键是检验测试能否查出错误，验收测试通常有下列四种方法：
a.逆向检查验收测试利用模块中的结果，计算本应采用的输入值，并与真实输入值比较以决定结果是否可接受。例如，如果恢复块提供的是平方根函数，那么验收检查就可以利用对结果平方并与输入值比较进行。
b.编码检查该方法的一个例子是利用一个数据系统，在该系统中数据记录具有对该记录内的数据进行求和检查其正确性的功能，
当数据更改后，这种和的结果将由软件来保持，这样在模块完成它的处理后通过重新计算和来检查记录中的数据讹误。
c.合理性检查这类测试的目的是为了决定模块执行后系统状态是否与系统设计要求相一致。通常，这种检查要求在模块执行前存取变量值以便与执行后的相应值进行比较。
d.结构检查考虑下面这种情况：恢复块里有一系列数据清单，这些清单仅以向前的方向相互连接，如果要想使清单双向连接，那么验收测试即可通过在两个方向上读数据来检查清单结果是否有讹误。
如同N版本编程法中的表决检查一样，验收测试也必须简单，否则就会增大设计故障发生的机会，且在测试很复杂时导致验收测试运行时间过长，而这是不允许的。
2.恢复块备选模块
恢复块中，所有模块均在恢复块的入口处，不管先前故障如何，各模块通常仍按恢复块规定的严格顺序执行，原因是设计故障只有处理状态的速率组合能够发现，这些处理状态在恢复块下次执行时不可能重新出现。
根据主模块和备选模块执行的这种顺序特性，可以利用下述三种方法来进行备选模块设计。
相同加权，独立设计设计的每个模块以最佳的方式提供完全相同的功能，其相异性可利用对各模块采用不同开发人员、开发工具和方法来保证。
优先的、全功能设计每个模块执行相同的功能，但有严格的执行顺序。例如，备选模块可以是主模块的未精练的老版本，且在改进期间引入的故障没有对其造成破坏。
功能降级的备选模块主模块提供全部功能，但备选模块提供逐次降级功能，备选模块可能是主模块的老版本（但功能改进没有受到破坏），）也可能是可降低软件复杂性和（或）执行时间的故障降级的版本。
需要说明的是采用降级的备选模块，验收测试也必须弱化。
对实时系统来讲，功能降级备选模块尤为有用，因为当遇到故障时，可能没有足够的时间执行全功能备选模块。
降级备选设计的一个特性是只有一个主模块和一个空备选模块，在这种情况下，恢复块的作用就是查错和从错误中恢复并略去发现故障的操作。
除了上面介绍的几种方法外，文件编制、失效数据处理方法、管理等对产生可靠的软件也是非常有用的。故障数据处理得当，对选择适当的软件模型，达到良好的可靠性是非常有用的；
管理是从机构上保证提高软件可靠性的基础，是摆脱软件手工作坊式的生产方式的一种有效的途径；软件生产也应像硬件一样成立一个程序设计师系统，以保证软件各模块的协调性，接口的合理性。
8.8软件可靠性验证
软件可靠性验证的目的是为了证实所开发的软件是否满足系统和软件的可靠性要求，它是保证软件和系统可靠性的一项重要措施。
软件可靠性验证不仅仅是验证软件可靠性的定量指标，还应验证软件可靠性的定性要求，验证通常可通过评审、分析和测试来进行。评审和分析主要评估软件定性要求是否达到、软件结构和源代码的精确性、完整性。
软件测试则是为了验证软件的定量要求并进一步评估定量要求的一致性和完整性，并证明与要求的符合程度。
需要说明的是下面所讲的许多测试并不是专门的软件可靠性测试，但是这些测试结果对改善软件的可靠性水平是有益的，其结果可用于软件的可靠性验证与评价。
8.8.1软件可靠性验证的准备及内容
软件可靠性验证前应首先拟定软件可靠性验证计划，其内容包括：
a.机构：确定负责验证的机构及其与其他软件开发过程中机构的关系；
b.独立程度：当要求时，应说明保证验证独立性的方法；
c.。验证方法：说明软件验证过程中各项活动所采用的验证方法，如评审方法（包括检查单或其他辅助方法）、分析方法（包括可跟踪性和覆盖分析）和测试方法（包括建立测试案例选择、测试程序和测试数据采集）；
d.验证环境：说明需要测试的设备、测试和分析工具以及应用这些工具和其他测试设计的指南；
e.转移准则：进入软件可靠性验证过程的准则；
f.划分考虑：如果需要划分，应对划分的完整性进行验证；
g.编译程序假设：负责验证的人应对编译程序、连接编译程序和连接装入程序的正确性作出假设；
h.再验证指南：对于改进的软件，应说明确定软件受影响的区域和可执行代码更改部分的方法，再验证应保证过去报告的错误或错误种类已经消除；
i.过去开发的软件：对过去开发的软件，如果验证过程初始符合性基线与该文件不一致，应说明满足文件目标的方法；
j.多版本非相似软件：如果使用多版本非相似软件，应说明软件验证的活动。
其次，应提交软件可靠性验证所需的输入，包括系统的可靠性要求、软件可靠性要求、结构、可跟踪性数据、源代码、可执行源代码。利用这些信息即可开始实施验证活动，以检查软件要求的实施和验证间的跟踪能力。
软件可靠性验证活动的内容主要包括：
a.验证软件的可靠性要求；
b.如果所测试的代码与软件不相同那么应说明他们的区别并说明存在的理由；
c.当不可能通过将软件在实际环境下运行来对其进行验证时，应提供其他的验证方法并说明采用该方法的理由；
d.在软件可靠性验证过程中发现缺陷和不足时，应向软件开发人员报告并请他们进行纠正。
8.8.2利用软件评审和分析进行验证
软件评审与分析的一个主要的不同点是，分析可提供重复的正确性证明，而评审则提供了正确性的定性评估。
评审主要利用检查单或其他类似的方法检查过程的输出，而分析则主要对软件成分的功能、性能、跟踪能力以及与系统中其他部件的关系进行检查。
8.8.2.1可靠性要求的评审和分析
该评审和分析的目的是为了检测和报告在软件需求过程中引入的需求错误，确认可靠性要求是否满足下述目标：
a.与系统要求相一致目的是保证已规定了软件将执行的系统功能，保证软件可靠性要求满足系统的功能、性能和可靠性有关的要求；
b.精确性和一致性目的是保证每项可靠性要求是精确的、不模糊的和足够详细的，且不会与其他要求相抵触；
c.与目标计算机的兼容性目的是保证可靠性要求与目标计算机的硬件、软件特性，尤其是响应时间和输入、输出硬件不会相抵触；
d.可验证性目的是保证可对每项可靠性要求进行验证；
e.与标准的符合性目的是保证在软件需求过程中软件需求标准得到遵循，如果偏离标准时应说明理由；
f.跟踪能力目的是保证系统的功能、性能和可靠性有关的要求正确分配到软件中；
g.算法方面保证所采用的算法的精确性，尤其是在不连续的区域的精确性。
8.8.2.2软件结构的评审和分析
该评审的目的是为了检测和报告软件结构开发过程中可能引入的错误，确认软件结构是否满足下述要求：
a.与可靠性要求的兼容性	目的是保证软件结构不会与可靠性要求，尤其是保证系统完整性的功能要求相冲突；
b.一致性	目的是保证软件结构各部件间的关系是正确的；
c.与目标计算机的兼容性	保证软件结构与目标计算机的硬、软件特性，如初始化、异步操作和中断间不会出现冲突；
d.可验证性	保证软件结构可以进行验证；
e.标准的符合性	保证在软件设计过程中软件设计标准得以遵循并当出现偏离标准时应说明现由；
f.划分的完整性。
8.8.2.3源代码的评审和分析
该评审和分析的目的是为了检测和报告软件编码过程中引入的错误，确认软件编码过程的输出是正确的、完整的和可以验证的，具体要求有：
a.与可靠性要求的一致性保证源代码相对软件可靠性要求来讲是精确的和完整的，并且不会实现文档规定之外的功能；
b.与软件结构的一致性保证源代码与软件结构中规定的数据流和控制功能流相匹配；
c.可验证性保证源代码不含有不能验证的语句和结构且代码无需修改即可测试；
d.与标准的符合性保证在编码期间，软件代码标准得以遵循；
e.精确性和一致性保证源代码的正确性和一致性。
8.8.2.4综合过程输出的评审和分析
该评审和分析的目的是为了保证综合过程的结果是完整的和正确的，这可通过详细检查连接和装入数据的存储变换来进行，基本内容包括：
a.错误的硬件地址；
b.存储器覆盖；
c.遗漏软件部件。
8.8.2.5测试案例、程序和结果的评审和分析
该评审和分析的目的是为了保证精确和完整地开发和执行编码测试，包括：
a.测试案例；
b.测试程序；
c.测试结果保证测试结果的正确性，当实际结果与预期的结果不一致时，解释造成这种情况的原因。
8.8.3利用测试进行验证
目前，软件主要有三种测试，一是硬件、软件综合测试，该测试是为了验证软件可以在目标计算机环境中正确使用；
二是软件综合测试，其目的是为了验证软件需求和部件间的相互关系和验证软件结构内软件需求和软件部件的实施情况；三是单元测试，它的目的是为了发现软件单元中功能和结构方面的不足。
8.8.3.1测试环境
测试环境是保证软件测试有效性的基础。通常所选择的测试应在综合的目标计算机环境下进行，因为某些错误只有在这样的环境下才可以检测出来。
8.8.3.2以要求为基础的测试案例选择
以要求为基础的测试是发现软件错误最有效的一种测试方法。这类测试主要包括两类，一是正常范围测试。二是健壮性测试，具体选用那种测试应根据软件需求和软件开发过程中的错误源确定。
1．正常范围测试案例
该测试的目的是为了验证软件对正常输入和条件的响应。它包括：
a.应利用有效的等效类和边界值检查实型和整型输入变量；
b.对于与时间相关的功能，如筛选程序、积分器等，应对其代码进行多次迭代，以检查该功能的特点；
c.应制定测试案例来检查正常使用期间可能遇到的各种状态转移；
d.。对于用逻辑方程表示的软件要求，正常范围测试案例应验证变量运算和逻辑算子。
2．健壮测试案例
该测试的目的是为了验证软件对异常输入和条件的响应。健壮测试案例包括：
a.实型和整型变量应利用无效值的等价类的选择进行检查；
b.应检查在不正常的条件下系统的初始化；
c.应确定输入数据可能的故障模式，尤其是来自外部系统的复杂的数字数据；
d.对于要计算循环次数的循环来讲，应制定能计算范围外循环值并能验证与循环有关的代码的健壮性的测试案例；
e.应进行检查以保证超出帧时间时仍能正确地响应；
f.对与时间有关的功能，如筛选程序、积分器等，应制定能防止运算溢出的测试案例；
g.应制定能诱发软件需求不允许的状态的测试案例。
8.8.3.3以要求为基础的测试方法
以要求为基础的测试方法包括以要求为基础的硬件、软件综合测试和以要求为基础的软件综合测试。除了硬件、软件综合测试外，这些方法没有规定具体的测试环境和策略。
1．以要求为基础的硬件、软件综合测试
这种测试主要用于发现在目标计算机环境内和在较高产品层次使用的软件的错误，其目的是为了保证在目标计算机上运行的软件将满足高级可靠性要求。这种测试方法所能发现的错误主要包括：
a.不正确的中断处理；
b.不能满足执行时间要求；
c.对硬件瞬态和故障不正确的软件响应；
d.数据总线和其他资源争用问题，如存储变换；
e.BIT不能检测故障；
f.硬件、软件接口错误；
g.反馈回路不正确的行为；
h.在软件控制下的存储管理硬件或其他硬件不正确的控制；
i.栈溢出；
j.在确认可装入字段软件的正确性和兼容性时，所采用的机理方面的错误；
k.软件划分被破坏。
2．以要求为基础的软件综合测试
这种测试方法主要集中处理软件需求的相互关系和软件的实现情况。其目的是为了保证软件各部件间相互作用的正确性和满足软件要求和软件结构要求。
该方法可通过扩展要求的范围（通过逐步代码综合）和相应扩展测试案例的范围来进行。该方法主要可以发现下述问题：
a.变量和常量的不正确的初始化；
b.参数传递错误；
c.数据恶化；
d.不适当的端一端数字分解；
e.不正确的事件和运算顺序。
8.8.3.4验证方案
软件可靠性验证方案可参考或借鉴GJB899的思路、方案，通过分析后加以确定。